<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Upload & Vorschau – content-preview</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>

  <style>
    :root { --bg: #f3f3f3; }
    html, body { height: 100%; margin: 0; font-family: system-ui, sans-serif; }
    header {
      display: flex; gap: 12px; align-items: center;
      padding: 10px 14px; border-bottom: 1px solid #ddd; background: #fff;
    }
    #uploadLabel {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 10px 14px; border-radius: 10px; cursor: pointer;
      background: #111; color: #fff; font-weight: 600;
    }
    #fileInput { display: none; }
    #content-preview {
      height: calc(100vh - 54px); /* Rest der Seite */
      background: var(--bg);
    }
    a-scene { width: 100%; height: 100%; touch-action: none; }
    .hint {
      margin-left: auto; color: #666; font-size: 12px;
    }
  </style>
</head>
<body>
  <header>
    <label id="uploadLabel" for="fileInput">Upload file</label>
    <input id="fileInput" type="file" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" />
    <span class="hint">Drehen: Maus ziehen · Zoomen: Mausrad / Pinch</span>
  </header>

  <div id="content-preview">
    <a-scene renderer="color: var(--bg)" embedded>
      <a-entity light="type: ambient; intensity: 0.9"></a-entity>
      <a-entity light="type: directional; intensity: 1.0" position="1 2 1"></a-entity>

      <!-- Modell-Container (wir ersetzen gltf-model dynamisch) -->
      <a-entity id="model" position="0 0 0" rotation="0 0 0" scale="1 1 1"></a-entity>

      <!-- Kamera (Zoom via Z-Position) -->
      <a-entity id="cam" camera position="0 1.6 6" look-controls="enabled:false" wasd-controls="enabled:false"></a-entity>
    </a-scene>
  </div>

  <script>
    const input = document.getElementById('fileInput');
    const scene = document.querySelector('a-scene');
    const model = document.getElementById('model');
    const cam   = document.getElementById('cam');

    // Interaktion (Drehen/Zoomen)
    const rotSpeed = 0.3;               // Grad pro Pixel
    const zoomMin  = 0.5, zoomMax = 200; // Zoomgrenzen
    const pinchFactor = 0.005;
    let isDragging=false, lastX=0, lastY=0, lastPinch=null;

    function clamp(v,a,b){ return Math.min(b, Math.max(a,v)); }
    function getRot(){ const r=model.getAttribute('rotation'); return {x:r.x,y:r.y,z:r.z}; }
    function setRot(x,y,z){ model.setAttribute('rotation', `${x} ${y} ${z}`); }
    function getZ(){ return cam.object3D.position.z; }
    function setZ(z){ cam.object3D.position.z = clamp(z, zoomMin, zoomMax); }

    // Datei laden → Objekt-URL → gltf-model setzen
    input.addEventListener('change', () => {
      const file = input.files && input.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      model.setAttribute('gltf-model', url);

      // Nach Laden: Bounding-Box fitten
      model.addEventListener('model-loaded', fitView, { once: true });
    });

    function fitView(){
      const mesh = model.getObject3D('mesh');
      if (!mesh) return;
      mesh.updateMatrixWorld(true);

      const box = new THREE.Box3().setFromObject(mesh);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);

      // Modell zum Weltursprung zentrieren (verschieben)
      const offset = center.clone().multiplyScalar(-1);
      model.object3D.position.copy(offset);

      // Kamera-Distanz schätzen (45° FOV) + Puffer
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = (cam.getObject3D('camera').fov || 60) * Math.PI / 180;
      const dist = (maxDim/2) / Math.tan(fov/2) + maxDim * 0.25;

      setZ(dist);
    }

    // Canvas-Interaktionen erst nach Szenen-Ladeende anbinden
    if (scene.hasLoaded) bindControls(); else scene.addEventListener('loaded', bindControls);

    function bindControls(){
      const canvas = scene.canvas;
      if (!canvas) return;

      canvas.addEventListener('pointerdown', e => {
        isDragging = true; lastX = e.clientX; lastY = e.clientY;
        canvas.setPointerCapture(e.pointerId);
      });
      canvas.addEventListener('pointermove', e => {
        if (!isDragging) return;
        const dx = e.clientX - lastX, dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;
        const r = getRot();
        setRot(clamp(r.x - dy*rotSpeed, -89, 89), r.y + dx*rotSpeed, r.z);
      });
      ['pointerup','pointercancel','pointerleave'].forEach(t => canvas.addEventListener(t, ()=>{isDragging=false;}));

      canvas.addEventListener('wheel', e => {
        e.preventDefault();
        setZ(getZ() + e.deltaY * 0.01);
      }, { passive:false });

      canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 1){
          lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
          isDragging = true; lastPinch = null;
        } else if (e.touches.length === 2){
          isDragging = false; lastPinch = dist(e.touches[0], e.touches[1]);
        }
      }, { passive:false });

      canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 1 && isDragging){
          const t = e.touches[0];
          const dx = t.clientX - lastX, dy = t.clientY - lastY;
          lastX = t.clientX; lastY = t.clientY;
          const r = getRot();
          setRot(clamp(r.x - dy*rotSpeed, -89, 89), r.y + dx*rotSpeed, r.z);
        } else if (e.touches.length === 2){
          const d = dist(e.touches[0], e.touches[1]);
          if (lastPinch != null){ setZ(getZ() + (lastPinch - d) * pinchFactor); }
          lastPinch = d;
        }
      }, { passive:false });

      canvas.addEventListener('touchend', ()=>{ isDragging=false; lastPinch=null; });

      function dist(a,b){ return Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY); }
    }
  </script>
</body>
</html>




