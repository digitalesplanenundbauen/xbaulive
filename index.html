<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />

        <!-- A-Frame itself -->
        <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>

        <!-- Pure three.js code that the A-Frame components use for location-based AR -->
        <script type='text/javascript' src='https://raw.githack.com/AR-js-org/AR.js/3.4.7/three.js/build/ar-threex-location-only.js'></script>

        <!-- AR.js A-Frame components -->
        <script type='text/javascript' src='https://raw.githack.com/AR-js-org/AR.js/3.4.7/aframe/build/aframe-ar.js'></script>

        <style>
          /* Infofenster unten */
          #info-box {
            position: fixed;       /* fixiert am Bildschirm, nicht in der AR-Szene */
            bottom: 0;             /* am unteren Rand */
            left: 0;
            width: 100%;           /* volle Breite */
            background: rgba(221,221,221,0.7); /* hellgrau mit Transparenz */
            color: #000;                       /* schwarze Schrift */
            font-family: sans-serif;
            font-size: 14px;
            padding: 10px;
            box-sizing: border-box;
            text-align: left;
          }
          #info-box .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
          #info-box input[type="number"]{ width:80px; padding:4px; }
          #info-box button{ padding:6px 10px; }
          #coords{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
        </style>
    </head>

    <body style="margin: 0; overflow: hidden;">
        <a-scene
            renderer="logarithmicDepthBuffer: true;"
            embedded
            loading-screen="enabled: false;"
            arjs="sourceType: webcam; gpsMinDistance: 2; debugUIEnabled: false;"
        >
            <a-assets>
                <a-asset-item
                    id="animated-asset"
                    src="assets/asset.glb"
                ></a-asset-item>
            </a-assets>

            <a-entity
                gltf-model="#animated-asset"
                scale="1.0 1.0 1.0"
                gps-entity-place="latitude: 47.8676806; longitude: 12.1091045;"
            ></a-entity>

            <a-camera gps-camera="minAccuracy: 50" rotation-reader></a-camera>

            <!--
            <a-camera
                id="cam"
                gps-camera="minAccuracy: 2000; simulateLatitude: 47.8668463; simulateLongitude: 12.1090135;"
                rotation-reader>
            </a-camera>
            -->
        </a-scene>

        <div id="info-box">
          <div>Version: 1.2</div>
          <div id="coords">AR.js: Lat – | Lon – | Acc – m</div>
          <div class="row" style="margin-top:6px;">
            <label for="samples">Samples:</label>
            <input id="samples" type="number" min="3" max="50" step="1" value="12" />
            <button id="btnRefine">Genauigkeit verbessern</button>
            <span id="status"></span>
          </div>
        </div>

        <script>
          // --- Anzeige der AR.js-Positionsupdates (nur Info) ---
          const coordsEl = document.getElementById('coords');
          window.addEventListener('gps-camera-update-position', (e) => {
            const p = e.detail?.position || {};
            const lat = (typeof p.latitude  === 'number') ? p.latitude.toFixed(6)  : '–';
            const lon = (typeof p.longitude === 'number') ? p.longitude.toFixed(6) : '–';
            const acc = (typeof p.accuracy  === 'number') ? Math.round(p.accuracy) : '–';
            coordsEl.textContent = `AR.js: Lat ${lat} | Lon ${lon} | Acc ${acc} m`;
          });

          // --- Mehrfach messen + gewichtet mitteln ---
          async function getPos() {
            return new Promise((res, rej) => navigator.geolocation.getCurrentPosition(res, rej, {
              enableHighAccuracy: true, timeout: 15000, maximumAge: 0
            }));
          }
          function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

          async function refine(n = 10){
            const pts = [];
            for (let i = 0; i < n; i++){
              try {
                const { coords: c } = await getPos();
                if (isFinite(c.latitude) && isFinite(c.longitude) && isFinite(c.accuracy)) {
                  // Messungen mit sehr schlechter Genauigkeit ignorieren (Schwellwert anpassbar)
                  if (c.accuracy <= 100) {
                    pts.push({ lat: c.latitude, lon: c.longitude, acc: c.accuracy });
                  }
                }
              } catch (_) {
                // Messfehler ignorieren, nächste Runde
              }
              await sleep(400); // kleine Pause zwischen Messungen
            }
            if (pts.length === 0) {
              throw new Error('Keine gültigen GPS-Messungen erhalten.');
            }
            // Gewichtete Mittelung (Gewicht = 1/acc^2)
            let sw = 0, slat = 0, slon = 0;
            pts.forEach(p => {
              const w = 1 / Math.max(1, p.acc * p.acc);
              sw += w; slat += w * p.lat; slon += w * p.lon;
            });
            return { lat: slat / sw, lon: slon / sw };
          }

          // --- Button-Integration: Ergebnis an AR.js schicken ---
          const btn   = document.getElementById('btnRefine');
          const stat  = document.getElementById('status');
          const sampI = document.getElementById('samples');
          let originSet = false;

          btn.addEventListener('click', async () => {
            if (!navigator.geolocation) {
              stat.textContent = 'Geolocation nicht verfügbar.';
              return;
            }
            btn.disabled = true;
            const n = Math.min(50, Math.max(3, parseInt(sampI.value || '12', 10)));
            stat.textContent = `messe… (0/${n})`;

            // Fortschritt grob anzeigen
            let count = 0;
            const origGetPos = getPos;
            // (Optional) schnelle Fortschrittsanzeige – hier simpel via Interceptor:
            getPos = async function(){
              const r = await origGetPos();
              count++; stat.textContent = `messe… (${count}/${n})`;
              return r;
            };

            try {
              const best = await refine(n);
              stat.textContent = `Resultat: Lat ${best.lat.toFixed(6)} | Lon ${best.lon.toFixed(6)}`;

              // AR.js so informieren, als käme diese Position vom System
              const detail = { position: { latitude: best.lat, longitude: best.lon, accuracy: 10 } };
              if (!originSet) {
                window.dispatchEvent(new CustomEvent('gps-camera-origin-set', { detail }));
                originSet = true;
              }
              window.dispatchEvent(new CustomEvent('gps-camera-update-position', { detail }));
            } catch (e) {
              stat.textContent = 'Fehler: ' + (e?.message || e);
            } finally {
              // Interceptor zurücksetzen
              getPos = origGetPos;
              btn.disabled = false;
            }
          });
        </script>
    </body>
</html>
