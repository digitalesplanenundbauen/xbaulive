<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>

    <!-- AR.js location-only + A-Frame Komponenten -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.7/three.js/build/ar-threex-location-only.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.7/aframe/build/aframe-ar.js"></script>

    <style>
      /* Fixiertes Infofenster unten */
      #info-box {
        position: fixed; bottom: 0; left: 0; width: 100%;
        background: rgba(221,221,221,0.7); color: #000;
        font-family: sans-serif; font-size: 14px; padding: 10px;
        box-sizing: border-box; text-align: left;
      }
      #info-box .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px; }
      #info-box input[type="number"] { width:110px; padding:4px; }
      #info-box button { padding:6px 10px; }
      #coords { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
      #status { min-height: 1.2em; }
    </style>
  </head>

  <body style="margin: 0; overflow: hidden;">
    <!-- ========== AR-Szene ========== -->
    <a-scene
      renderer="logarithmicDepthBuffer: true;"
      embedded
      loading-screen="enabled: false;"
      arjs="sourceType: webcam; gpsMinDistance: 2; debugUIEnabled: false;"
    >
      <a-assets>
        <a-asset-item id="animated-asset" src="assets/asset.glb"></a-asset-item>
      </a-assets>

      <a-entity
        gltf-model="#animated-asset"
        scale="1 1 1"
        gps-entity-place="latitude: 47.8676806; longitude: 12.1091045;">
      </a-entity>

      <!-- Startuntergrenze: 50 (darunter ignoriert AR.js oft Updates) -->
      <a-camera gps-camera="minAccuracy: 50" rotation-reader></a-camera>
    </a-scene>

    <!-- ========== UI / Infofenster ========== -->
    <div id="info-box">
      <div>Version: 1.4</div>
      <div id="coords">AR.js: Lat – | Lon – | Acc – m</div>

      <!-- Zeile 1: Fix Position 1 (n Messungen, gewichtet mitteln, festsetzen) -->
      <div class="row">
        <label for="samples">Messungen:</label>
        <input id="samples" type="number" min="3" max="50" step="1" value="12" />
        <button id="btnFix1">Fix Position 1</button>
        <span id="status"></span>
      </div>

      <!-- Zeile 2: Fix Position 2 (messen bis Zielgenauigkeit, festsetzen) -->
      <div class="row">
        <label for="accTarget">Zielgenauigkeit (m):</label>
        <input id="accTarget" type="number" min="1" step="1" value="2" />
        <button id="btnFix2">Fix Position 2</button>
      </div>

      <!-- Zeile 3: Auto Position (echtes GPS; Mindestgenauigkeit direkt an AR.js) -->
      <div class="row">
        <label for="minAccInput">Mindestgenauigkeit:</label>
        <input id="minAccInput" type="number" min="1" step="1" value="100" />
        <button id="btnAuto">Auto Position</button>
      </div>
    </div>

    <script>
      /* =================== Allgemeine Referenzen & Anzeige =================== */

      const coordsEl = document.getElementById("coords");
      const stat = document.getElementById("status");

      // Modus-Flags
      let mode = "auto";            // "auto" oder "fixed"
      let currentAutoMinAcc = 50;   // aktuell gesetzte Mindestgenauigkeit im Auto-Modus

      // AR.js-Positions-Events anzeigen — im Auto-Modus nur, wenn acc ≤ currentAutoMinAcc
      window.addEventListener("gps-camera-update-position", (e) => {
        const p = e.detail?.position || {};
        const lat = (typeof p.latitude  === "number") ? p.latitude.toFixed(6) : "–";
        const lon = (typeof p.longitude === "number") ? p.longitude.toFixed(6) : "–";
        const accNum = (typeof p.accuracy === "number") ? p.accuracy : undefined;
        const accStr = (accNum != null) ? Math.round(accNum) : "–";

        if (mode === "auto") {
          // Nur anzeigen, wenn AR.js unterhalb der eingestellten Mindestgenauigkeit meldet
          if (accNum != null && accNum <= currentAutoMinAcc) {
            coordsEl.textContent = `AR.js: Lat ${lat} | Lon ${lon} | Acc ${accStr} m`;
          }
        } else {
          // Im Fixed-Modus lassen wir die manuell gesetzte Anzeige stehen
        }
      });

      // Zugriff auf gps-camera
      const getGpsCameraEl  = () => document.querySelector("[gps-camera]");
      const getGpsCameraCmp = () => getGpsCameraEl()?.components?.["gps-camera"] || null;

      /* =================== Fix-Position anwenden (Simulation) ===================

         Wir setzen simulateLatitude/Longitude auf dem *bestehenden* Component,
         lassen AR.js die Werte einlesen (play, 1–2 Frames warten) und pausieren
         anschließend wieder, damit die Position wirklich „fest“ bleibt.
      ========================================================================== */
      async function setFixedPosition(lat, lon, shownAcc = 10) {
        const camEl  = getGpsCameraEl();
        const camCmp = getGpsCameraCmp();
        if (!camEl || !camCmp) throw new Error("gps-camera nicht bereit");

        // Simulation setzen (ohne das Component zu entfernen/recreaten)
        camEl.setAttribute("gps-camera", {
          simulateLatitude: lat,
          simulateLongitude: lon,
          minAccuracy: 1
        });

        // kurz starten, 2 Frames warten, dann pausieren
        camCmp.play();
        await new Promise(r => requestAnimationFrame(r));
        await new Promise(r => requestAnimationFrame(r));
        camCmp.pause();

        // Info im UI aktualisieren (fest gesetzte Position)
        coordsEl.textContent =
          `AR.js (fix): Lat ${lat.toFixed(6)} | Lon ${lon.toFixed(6)} | Acc ~${Math.round(shownAcc)} m`;
        mode = "fixed";
      }

      /* =================== Auto-Position aktivieren ===================

         - Simulation *deaktivieren* indem wir sie auf null setzen
         - minAccuracy direkt an AR.js übergeben
         - Component spielen lassen (echtes GPS aktiv)
      ================================================================== */
      function enableAutoPosition(minAcc) {
        const camEl  = getGpsCameraEl();
        const camCmp = getGpsCameraCmp();
        if (!camEl || !camCmp) throw new Error("gps-camera nicht bereit");

        // Mindestgenauigkeit setzen; Simulation ausschalten
        camEl.setAttribute("gps-camera", {
          simulateLatitude: null,
          simulateLongitude: null,
          minAccuracy: minAcc
        });

        camCmp.play();         // echte Geoposition wieder aktiv
        mode = "auto";
        currentAutoMinAcc = minAcc;
      }

      /* =================== Geolocation & Statistik-Helfer =================== */

      // Einmalige Messung
      async function getPos() {
        return new Promise((res, rej) =>
          navigator.geolocation.getCurrentPosition(res, rej, {
            enableHighAccuracy: true, timeout: 15000, maximumAge: 0
          })
        );
      }
      const sleep = (ms) => new Promise(r => setTimeout(r, ms));

      // Gewichtetes Mittel aus n Messungen, inkl. *gewichteter* mittlerer Accuracy
      async function refine(n = 10, onProgress = () => {}, isCancelled = () => false) {
        const pts = [];
        for (let i = 0; i < n; i++) {
          if (isCancelled()) throw new Error("abgebrochen");
          try {
            const { coords: c } = await getPos();
            if (isCancelled()) throw new Error("abgebrochen");
            if (isFinite(c.latitude) && isFinite(c.longitude) && isFinite(c.accuracy) && c.accuracy <= 100) {
              pts.push({ lat: c.latitude, lon: c.longitude, acc: c.accuracy });
            }
            onProgress(i + 1, n, c.accuracy, runningAccMean(pts));
          } catch (_) {}
          await sleep(400);
        }
        if (pts.length === 0) throw new Error("Keine gültigen GPS-Messungen erhalten.");

        // Gewichtete Mittelwerte for lat, lon, acc
        let sw=0, slat=0, slon=0, sacc=0;
        pts.forEach(p => { const w = 1 / Math.max(1, p.acc * p.acc); sw+=w; slat+=w*p.lat; slon+=w*p.lon; sacc+=w*p.acc; });
        return { lat: slat/sw, lon: slon/sw, accMean: sacc/sw };
      }

      // Messen bis Zielgenauigkeit erreicht; Status zeigt aktuelle Mess-Accuracy + laufenden Mittelwert
      async function refineUntil(targetAcc = 2, onProgress = () => {}, isCancelled = () => false) {
        const pts = [];
        while (true) {
          if (isCancelled()) throw new Error("abgebrochen");
          try {
            const { coords: c } = await getPos();
            if (isCancelled()) throw new Error("abgebrochen");
            if (isFinite(c.latitude) && isFinite(c.longitude) && isFinite(c.accuracy)) {
              pts.push({ lat: c.latitude, lon: c.longitude, acc: c.accuracy });
              onProgress(pts.length, null, c.accuracy, runningAccMean(pts)); // count, _, currentAcc, accMeanSoFar
              if (c.accuracy <= targetAcc) break;
            }
          } catch (_) {}
          await sleep(400);
        }

        // Schrottwerte >100 m raus (falls alles >100 war, nimm alle)
        const use = pts.filter(p => p.acc <= 100);
        const arr = use.length ? use : pts;

        let sw=0, slat=0, slon=0, sacc=0;
        arr.forEach(p => { const w = 1 / Math.max(1, p.acc * p.acc); sw+=w; slat+=w*p.lat; slon+=w*p.lon; sacc+=w*p.acc; });
        return { lat: slat/sw, lon: slon/sw, samples: arr.length, accMean: sacc/sw };
      }

      // Laufender (gewichteter) Mittelwert der Accuracy (für Status-Ausgabe)
      function runningAccMean(pts) {
        if (!pts.length) return undefined;
        let sw=0, sacc=0;
        pts.forEach(p => { const w = 1 / Math.max(1, p.acc * p.acc); sw+=w; sacc+=w*p.acc; });
        return sacc / sw;
      }

      /* =================== Abbruch-Handling =================== */

      // Jede neue Aktion invalidiert die vorherige
      let activeOpId = 0;
      const beginOp     = () => (++activeOpId);
      const isCancelled = (id) => id !== activeOpId;
      const cancelActive= () => { activeOpId++; };

      /* =================== UI-Logik / Buttons =================== */

      const btnFix1     = document.getElementById("btnFix1");
      const btnFix2     = document.getElementById("btnFix2");
      const btnAuto     = document.getElementById("btnAuto");
      const sampI       = document.getElementById("samples");
      const accTargetI  = document.getElementById("accTarget");
      const minAccI     = document.getElementById("minAccInput");

      // Fix Position 1: n Messungen, mitteln, an AR.js übertragen, festsetzen
      btnFix1.addEventListener("click", async () => {
        cancelActive();
        const myId = beginOp();

        const n = Math.min(50, Math.max(3, parseInt(sampI.value || "12", 10)));
        stat.textContent = `Fix1: messe… (0/${n})`;

        try {
          const best = await refine(
            n,
            (i, total, accNow, accMean) => {
              if (isCancelled(myId)) throw new Error("abgebrochen");
              stat.textContent = `Fix1: (${i}/${total}) | aktuell: ${Math.round(accNow||0)} m | berechnet: ${accMean ? accMean.toFixed(1) : "–"} m`;
            },
            () => isCancelled(myId)
          );
          if (isCancelled(myId)) throw new Error("abgebrochen");

          // >>> verfeinerte Position wirklich anwenden + berechnete Accuracy anzeigen
          await setFixedPosition(best.lat, best.lon, best.accMean);
          stat.textContent = `Fix1 fest: Lat ${best.lat.toFixed(6)} | Lon ${best.lon.toFixed(6)} | Acc ~${best.accMean.toFixed(1)} m`;
        } catch (e) {
          if (e?.message !== "abgebrochen") stat.textContent = "Fehler: " + (e?.message || e);
          else stat.textContent = "Abgebrochen.";
        }
      });

      // Fix Position 2: messen bis Zielgenauigkeit erreicht, anwenden, festsetzen
      btnFix2.addEventListener("click", async () => {
        cancelActive();
        const myId = beginOp();

        const target = Math.max(1, parseInt(accTargetI.value || "2", 10));
        stat.textContent = `Fix2: Ziel ${target} m – messe…`;

        try {
          const best = await refineUntil(
            target,
            (count, _t, accNow, accMean) => {
              if (isCancelled(myId)) throw new Error("abgebrochen");
              stat.textContent = `Fix2: Messung ${count} | aktuell: ${Math.round(accNow||0)} m | berechnet: ${accMean ? accMean.toFixed(1) : "–"} m (Ziel: ${target} m)`;
            },
            () => isCancelled(myId)
          );
          if (isCancelled(myId)) throw new Error("abgebrochen");

          await setFixedPosition(best.lat, best.lon, best.accMean);
          stat.textContent = `Fix2 fest: Lat ${best.lat.toFixed(6)} | Lon ${best.lon.toFixed(6)} | Acc ~${best.accMean.toFixed(1)} m (n=${best.samples})`;
        } catch (e) {
          if (e?.message !== "abgebrochen") stat.textContent = "Fehler: " + (e?.message || e);
          else stat.textContent = "Abgebrochen.";
        }
      });

      // Auto Position: Simulation aus, Mindestgenauigkeit direkt an AR.js, echte GPS-Updates
      btnAuto.addEventListener("click", () => {
        cancelActive();

        // Eingabewert clampen (AR.js sinnvoll erst ab 50 m)
        let minAcc = Math.max(1, parseInt(minAccI.value || "100", 10));
        if (minAcc < 50) {
          minAcc = 50;
          minAccI.value = 50;
          stat.textContent = "Mindestgenauigkeit < 50 nicht erlaubt, auf 50 gesetzt.";
        } else {
          stat.textContent = `Auto-Position aktiv (Mindestgenauigkeit: ${minAcc})`;
        }

        try {
          enableAutoPosition(minAcc);
        } catch (e) {
          stat.textContent = "Fehler (Auto): " + (e?.message || e);
        }
      });
    </script>
  </body>
</html>
