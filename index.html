<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />

        <!-- A-Frame itself -->
        <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>

        <!-- Pure three.js code that the A-Frame components use for location-based AR -->
        <script type='text/javascript' src='https://raw.githack.com/AR-js-org/AR.js/3.4.7/three.js/build/ar-threex-location-only.js'></script>

        <!-- AR.js A-Frame components -->
        <script type='text/javascript' src='https://raw.githack.com/AR-js-org/AR.js/3.4.7/aframe/build/aframe-ar.js'></script>

        <style>
          /* Infofenster unten */
          #info-box {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(221,221,221,0.7);
            color: #000;
            font-family: sans-serif;
            font-size: 14px;
            padding: 10px;
            box-sizing: border-box;
            text-align: left;
          }
          #info-box .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px; }
          #info-box input[type="number"]{ width:90px; padding:4px; }
          #info-box button{ padding:6px 10px; }
          #coords{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
        </style>
    </head>

    <body style="margin: 0; overflow: hidden;">
        <a-scene
            renderer="logarithmicDepthBuffer: true;"
            embedded
            loading-screen="enabled: false;"
            arjs="sourceType: webcam; gpsMinDistance: 2; debugUIEnabled: false;"
        >
            <a-assets>
                <a-asset-item
                    id="animated-asset"
                    src="assets/asset.glb"
                ></a-asset-item>
            </a-assets>

            <a-entity
                gltf-model="#animated-asset"
                scale="1.0 1.0 1.0"
                gps-entity-place="latitude: 47.8676806; longitude: 12.1091045;"
            ></a-entity>

            <a-camera gps-camera="minAccuracy: 50" rotation-reader></a-camera>
        </a-scene>

        <div id="info-box">
          <div>Version: 1.4</div>
          <div id="coords">AR.js: Lat – | Lon – | Acc – m</div>

          <!-- Zeile 1: Fix Position 1 (Samples-basiert) -->
          <div class="row">
            <label for="samples">Samples:</label>
            <input id="samples" type="number" min="3" max="50" step="1" value="12" />
            <button id="btnFix1">Fix Position 1</button>
            <span id="status"></span>
          </div>

          <!-- Zeile 2: Fix Position 2 (bis Zielgenauigkeit, Timeout 3 min) -->
          <div class="row">
            <label for="accTarget">Zielgenauigkeit (m):</label>
            <input id="accTarget" type="number" min="1" step="1" value="2" />
            <button id="btnFix2">Fix Position 2</button>
          </div>

          <!-- Zeile 3: Auto Position mit einstellbarer minAccuracy -->
          <div class="row">
            <label for="minAccInput">minAccuracy:</label>
            <input id="minAccInput" type="number" min="1" step="1" value="100" />
            <button id="btnAuto">Auto Position</button>
          </div>
        </div>

        <script>
          // --- Anzeige der AR.js-Positionsupdates (nur Info) ---
          const coordsEl = document.getElementById('coords');
          window.addEventListener('gps-camera-update-position', (e) => {
            const p = e.detail?.position || {};
            const lat = (typeof p.latitude  === 'number') ? p.latitude.toFixed(6)  : '–';
            const lon = (typeof p.longitude === 'number') ? p.longitude.toFixed(6) : '–';
            const acc = (typeof p.accuracy  === 'number') ? Math.round(p.accuracy) : '–';
            coordsEl.textContent = `AR.js: Lat ${lat} | Lon ${lon} | Acc ${acc} m`;
          });

          // --- Geolocation Helpers ---
          async function getPos() {
            return new Promise((res, rej) => navigator.geolocation.getCurrentPosition(res, rej, {
              enableHighAccuracy: true, timeout: 15000, maximumAge: 0
            }));
          }
          function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

          // Gewichtetes Mittel mehrerer Messungen (Gewicht = 1/acc^2), schlechte >100 m verwerfen
          async function refine(n = 10){
            const pts = [];
            for (let i = 0; i < n; i++){
              try {
                const { coords: c } = await getPos();
                if (isFinite(c.latitude) && isFinite(c.longitude) && isFinite(c.accuracy) && c.accuracy <= 100) {
                  pts.push({ lat: c.latitude, lon: c.longitude, acc: c.accuracy });
                }
              } catch (_) {}
              await sleep(400);
            }
            if (pts.length === 0) throw new Error('Keine gültigen GPS-Messungen erhalten.');
            let sw = 0, slat = 0, slon = 0;
            pts.forEach(p => { const w = 1 / Math.max(1, p.acc * p.acc); sw += w; slat += w * p.lat; slon += w * p.lon; });
            return { lat: slat / sw, lon: slon / sw };
          }

          // Misst fortlaufend bis acc <= targetAcc (m) ODER Timeout erreicht; bildet am Ende weighted mean
          async function refineUntil(targetAcc = 2, timeoutMs = 180000){
            const pts = [];
            const t0 = Date.now();
            let goodCount = 0;

            while (Date.now() - t0 < timeoutMs) {
              try {
                const { coords: c } = await getPos();
                if (isFinite(c.latitude) && isFinite(c.longitude) && isFinite(c.accuracy)) {
                  pts.push({ lat: c.latitude, lon: c.longitude, acc: c.accuracy });
                  if (c.accuracy <= targetAcc) goodCount++;
                  // optional: bei z.B. 3 „guten“ Fixen frühzeitig stoppen
                  if (goodCount >= 3) break;
                }
              } catch (_) {}
              await sleep(400);
            }

            if (pts.length === 0) throw new Error('Keine gültigen GPS-Messungen erhalten.');

            // Weighted mean über ALLE Messungen, aber sehr schlechte >100 m ignorieren
            const filtered = pts.filter(p => p.acc <= 100);
            if (filtered.length === 0) throw new Error('Nur sehr ungenaue Messungen (>100 m).');

            let sw = 0, slat = 0, slon = 0;
            filtered.forEach(p => { const w = 1 / Math.max(1, p.acc * p.acc); sw += w; slat += w * p.lat; slon += w * p.lon; });
            return { lat: slat / sw, lon: slon / sw, samples: filtered.length };
          }

          // --- Buttons & Lock/Unlock-Logik ---
          const btnFix1   = document.getElementById('btnFix1');
          const btnFix2   = document.getElementById('btnFix2');
          const btnAuto   = document.getElementById('btnAuto');
          const stat      = document.getElementById('status');
          const sampI     = document.getElementById('samples');
          const accTargetI= document.getElementById('accTarget');
          const minAccI   = document.getElementById('minAccInput');

          let originSet = false;

          function getGpsCameraEl(){ return document.querySelector('[gps-camera]'); }
          function getGpsCameraComponent(){
            const camEl = getGpsCameraEl();
            return camEl?.components?.['gps-camera'] || null;
          }

          function applyARPosition(lat, lon, acc = 10){
            const detail = { position: { latitude: lat, longitude: lon, accuracy: acc } };
            if (!originSet) {
              window.dispatchEvent(new CustomEvent('gps-camera-origin-set', { detail }));
              originSet = true;
            }
            window.dispatchEvent(new CustomEvent('gps-camera-update-position', { detail }));
          }

          // Fix Position 1 (Samples-basiert, setzt & pausiert)
          btnFix1.addEventListener('click', async () => {
            if (!navigator.geolocation) { stat.textContent = 'Geolocation nicht verfügbar.'; return; }
            btnFix1.disabled = true;
            const n = Math.min(50, Math.max(3, parseInt(sampI.value || '12', 10)));
            stat.textContent = `Fix1: messe… (0/${n})`;

            let count = 0;
            const origGetPos = getPos;
            getPos = async function(){
              const r = await origGetPos();
              count++; stat.textContent = `Fix1: messe… (${count}/${n})`;
              return r;
            };

            try {
              const best = await refine(n);
              stat.textContent = `Fix1 gesetzt: Lat ${best.lat.toFixed(6)} | Lon ${best.lon.toFixed(6)}`;
              applyARPosition(best.lat, best.lon, 10);

              // gps-camera pausieren (Position festsetzen)
              const gpsCam = getGpsCameraComponent();
              if (gpsCam) { gpsCam.pause(); stat.textContent += ' | (festgesetzt)'; }
            } catch (e) {
              stat.textContent = 'Fehler: ' + (e?.message || e);
            } finally {
              getPos = origGetPos;
              btnFix1.disabled = false;
            }
          });

          // Fix Position 2 (bis Zielgenauigkeit, Timeout 3min, setzt & pausiert)
          btnFix2.addEventListener('click', async () => {
            if (!navigator.geolocation) { stat.textContent = 'Geolocation nicht verfügbar.'; return; }
            btnFix2.disabled = true;
            const target = Math.max(1, parseInt(accTargetI.value || '2', 10));
            const timeoutMs = 180000; // 3 Minuten
            stat.textContent = `Fix2: Ziel ${target} m, Timeout 3 min – messe…`;

            try {
              const best = await refineUntil(target, timeoutMs);
              stat.textContent = `Fix2 gesetzt: Lat ${best.lat.toFixed(6)} | Lon ${best.lon.toFixed(6)} (n=${best.samples})`;
              applyARPosition(best.lat, best.lon, target);

              const gpsCam = getGpsCameraComponent();
              if (gpsCam) { gpsCam.pause(); stat.textContent += ' | (festgesetzt)'; }
            } catch (e) {
              stat.textContent = 'Fehler: ' + (e?.message || e);
            } finally {
              btnFix2.disabled = false;
            }
          });

          // Auto Position (gps-camera wieder starten + minAccuracy anwenden)
          btnAuto.addEventListener('click', () => {
            const gpsCamEl = getGpsCameraEl();
            const gpsCam   = getGpsCameraComponent();
            if (!gpsCamEl || !gpsCam) { stat.textContent = 'gps-camera nicht bereit'; return; }

            const minAcc = Math.max(1, parseInt(minAccI.value || '100', 10));
            gpsCamEl.setAttribute('gps-camera', `minAccuracy: ${minAcc}`);
            gpsCam.play(); // automatische Updates wieder aktiv
            stat.textContent = `Auto-Position aktiv (minAccuracy: ${minAcc})`;
          });
        </script>
    </body>
</html>
