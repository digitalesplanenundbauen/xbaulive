<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="robots" content="noindex">
  <meta name="color-scheme" content="light" />
  <link rel="stylesheet" href="style.css" />
  <title>Technologiepark & Studierendenzentrum – Viewer</title>
    
  <!-- A-Frame + AR.js -->
  <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
  
  
  <!--Statistik Deviora-->
  <script>
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//stats.deviora.de/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '2']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
</head>

<body>
  <!-- Popup für Sensorzugriff -->
  <div id="sensor-popup" style="display:none;">
    <div id="sensor-popup-content">
      <span class="popup-text">
        Diese Anwendung benötigt für seine Funktion <br> 
        den Zugriff auf die Sensoren deines Gerätes.
      </span>
      <br>
      <br>
      <button id="sensor-popup-ok" class="popup-btn">Ok</button>
    </div>
  </div>

  <!-- =====================
       Kopfzeile
       ===================== -->
  <header>
    <div class="header-inner">
      <div class="site-title" aria-label="Projektname">
        Technologiepark <br>
        &amp; Studierendenzentrum
      </div>
      <img class="logo" src="./images/thlogoweiss.svg" alt="Logo" />
    </div>
  </header>

  <!-- =====================
       Hauptbereich: 3D-Viewer
       ===================== -->
  <main>
    <div id="content-preview">
      <a-scene embedded xr-mode-ui="enabled: false">
        <!-- Lichtquellen -->
        <a-entity light="type: ambient; intensity: 0.9"></a-entity>
        <a-entity light="type: directional; intensity: 1.8" position="1 2 1"></a-entity>
        <!-- 3D-Modell -->
        <a-entity id="model" position="10 0 10" rotation="10 7 1" scale="1 1 1"></a-entity>
        <!-- Kamera -->
        <a-entity id="cam" camera position="0 0 0" look-controls="enabled:false" wasd-controls="enabled:false"></a-entity>
      </a-scene>
    </div>
  </main>

  <!-- =====================
       Fußzeile
       ===================== -->
  <footer>
    <div class="footer-top">
      <button class="footer-btn" id="liveBtn">Live</button>
      <span class="footer-text">Lass dir das Gebäude <br> in der Realität darstellen.</span>
    </div>
    <div class="footer-bottom">
      <span class="footer-lab"><strong>Labor für digitales Planen und Bauen</strong> – Raum S 0.36</span>
    </div>
  </footer>

  <!-- =====================
       Interaktion & Funktion
       ===================== -->
  <script>
    // Popup-Logik
    function shouldShowPopup() {
      return !/hideSensorPopup=1/.test(location.search);
    }
    if (shouldShowPopup()) {
      document.getElementById('sensor-popup').style.display = '';
    }
    document.getElementById('sensor-popup-ok').onclick = function() {
      document.getElementById('sensor-popup').style.display = 'none';
    };

    // === GLB Viewer ===
    const scene = document.querySelector('a-scene');
    const model = document.getElementById('model');
    const cam   = document.getElementById('cam');
    const GLB_URL = './assets/gameobjectohnekellerreduziert.glb';

    // Steuerungsparameter
    const rotSpeed = 0.3; // deg per px
    const zoomMin = 0.5, zoomMax = 200, pinchFactor = 0.005;
    let isDragging=false, lastX=0, lastY=0, lastPinch=null;

    // Hilfsfunktionen
    function clamp(v,a,b){ return Math.min(b, Math.max(a,v)); }
    function getRot(){ const r=model.getAttribute('rotation'); return {x:r.x,y:r.y,z:r.z}; }
    function setRot(x,y,z){ model.setAttribute('rotation', `${x} ${y} ${z}`); }
    function getZ(){ return cam.object3D.position.z; }
    function setZ(z){ cam.object3D.position.z = clamp(z, zoomMin, zoomMax); }

    // Modell laden
    function loadGLB(){
      model.setAttribute('gltf-model', GLB_URL);
      model.addEventListener('model-loaded', fitView, { once:true });
    }

    // Kamera auf Modell anpassen
    function fitView(){
      const mesh = model.getObject3D('mesh'); if (!mesh) return;
      mesh.updateMatrixWorld(true);
      const box = new THREE.Box3().setFromObject(mesh);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      model.object3D.position.copy(center.multiplyScalar(-1));
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = (cam.getObject3D('camera').fov || 60) * Math.PI/180;
      const dist = (maxDim/2)/Math.tan(fov/2) + maxDim*0.25;
      setZ(dist);
    }

    // Benutzersteuerung (Maus + Touch)
    function bindControls(){
      const canvas = scene.canvas; if (!canvas) return;
      canvas.addEventListener('pointerdown', e=>{ isDragging=true; lastX=e.clientX; lastY=e.clientY; canvas.setPointerCapture(e.pointerId); });
      canvas.addEventListener('pointermove', e=>{
        if (!isDragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
        const r=getRot(); setRot(clamp(r.x + dy*rotSpeed, -89, 89), r.y + dx*rotSpeed, r.z);
      });
      ['pointerup','pointercancel','pointerleave'].forEach(t=>canvas.addEventListener(t,()=>{isDragging=false;}));
      canvas.addEventListener('wheel', e=>{ e.preventDefault(); setZ(getZ() + e.deltaY*0.01); }, {passive:false});
      canvas.addEventListener('touchstart', e=>{ if (e.touches.length===1){ lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; isDragging=true; lastPinch=null; } else if (e.touches.length===2){ isDragging=false; lastPinch=dist(e.touches[0], e.touches[1]); } }, {passive:false});
      canvas.addEventListener('touchmove', e=>{ e.preventDefault(); if (e.touches.length===1 && isDragging){ const t=e.touches[0]; const dx=t.clientX-lastX, dy=t.clientY-lastY; lastX=t.clientX; lastY=t.clientY; const r=getRot(); setRot(clamp(r.x + dy*rotSpeed, -89, 89), r.y + dx*rotSpeed, r.z); } else if (e.touches.length===2){ const d=dist(e.touches[0], e.touches[1]); if (lastPinch!=null){ setZ(getZ() + (lastPinch-d)*pinchFactor); } lastPinch=d; } }, {passive:false});
      canvas.addEventListener('touchend', ()=>{ isDragging=false; lastPinch=null; });
      function dist(a,b){ return Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY); }
    }

    // Initialisierung nach Laden der Szene
    if (scene.hasLoaded) afterScene(); else scene.addEventListener('loaded', afterScene);
    function afterScene(){ loadGLB(); bindControls(); }

    // Navigation zur Live-Ansicht
    document.getElementById('liveBtn')?.addEventListener('click', ()=>{ location.href = 'live.html'; });
  </script>
</body>
</html>